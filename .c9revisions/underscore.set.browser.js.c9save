{"ts":1342481881850,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"//requires underscore.js & JSON.js\n/*\n * This is a functional implementation of a SET\n * adding and removing from sets do not overwrite previous values of the set\n */\nfunction Set(initial_items){\n    if(initial_items && !_.isObject(initial_items)){\n\tthrow \"the set must be given a list of initial items, or empty arguments\"\n    }\n    function initialize_items(initial_items){\n\treturn _.chain(initial_items || [])\n\t.map(JSON.stringify) //make hashes\n\t.zip(initial_items) //pair hashes with items\n\t.unique(false,_.first) //not sorted\n\t.reduce(function(list,item_hash_pair){\n\t\t    var hash = item_hash_pair[0];\n\t\t    var item = item_hash_pair[1];\n\t\t    list[hash] = item;\n\t\t    return list;\n\t\t},{})\n\t.value();\n    }\n\n    return (function Trusted_Set(set_items, passed_values){\n\t   var items = set_items;\n\t   return {\n\t       add:function(item){\n\t\t   var item_hash = JSON.stringify(item); //only works for sets\n\t\t   var new_set = _.clone(items);\n\t\t   new_set[item_hash] = item;\n\t\t   return Trusted_Set(new_set);\n\t       },\n\t       remove:function(item){\n\t\t   var item_hash = JSON.stringify(item); //only works for sets\n\t\t   var new_set = _.clone(items);\n\t\t   delete new_set[item_hash];\n\t\t   return Trusted_Set(new_set);\n\t       },\n\t       exists:function(item){\n\t\t   var item_hash = JSON.stringify(item); //only works for sets\n\t\t   return _.has(items,item_hash);\n\t       },\n\t       list:function(){\n\t\t   return _.values(items);\n\t       }\n\t   }\n       })\n    (initialize_items(initial_items || []))\n}"]],"start1":0,"start2":0,"length1":0,"length2":1495}]],"length":1495}
